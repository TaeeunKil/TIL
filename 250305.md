# TIL

# 수업
<details>
<summary> 요약 </summary>
  
  
## 연습문제
```python
'''
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
'''
def pre_order(T):
    if T:
        print(T, end = ' ')
        pre_order(left[T])
        pre_order(right[T])

N = int(input())        # 1번부터 N번까지인 정점
E = N-1
arr = list(map(int, input().split()))
left = [0]*(N+1)        # 부모를 인덱스로 왼쪽자식번호 저장
right = [0]*(N+1)       #
par = [0]*(N+1)         # 자식을 인덱스로 부모 저장

for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
# for i in range(0,E*2, 2):
#         p, c = arr[i], arr[i + 1]
    if left[p]==0:          # 왼쪽자식이 없으면
        left[p] = c
    else:
        right[p] = c
    par[c] = p

c = N
while par[c]!=0:        # 부모가 있으면
    c = par[c]          # 부모를 새로운 자식으로 두고
root = c                # 더이상 부모가 없으면 root
print(root)
pre_order(root)
```


## BST, Binary Search Tree - 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 자료 구조
- 모든 원소는 서로 다른 유일한 키를 갖는다
- 루트를 기준으로 왼쪽은 루트보다 작고 오른쪽은 루트보다 크다
- 왼쪽 서브트리와 오른쪽 서브트리도 이진탐색 트리다.
- 중위 순회하면 오름차순!

![image](https://github.com/user-attachments/assets/007944d4-544c-491f-a00d-72859711cc83)

- 탐색 연산
    - 루트 시작
    - 탐색할 값과 루트를 비교해서 같으면 성공, 작으면 왼쪽으로 크면 오른쪽으로

- 삽입 연산
    - 탐색 연산을 수행
    - 탐색이 성공하면 불가능
    - 탐색이 실패하면 그게 결정된 위치를 기준으로 삽입

- 탐색 삽입 삭제 시간은 트리의 높이 만큼. O(h) 

- 평균의 경우- 이진 트리가 균형적으로 생성되어 있는 경우는 O(log n)  [red-black tree?]

- 최악의 경우 한쪽으로 치우쳐서 O(n)

- 검색 알고리즘의 비교
    - 배열 순차, 정렬된 배열 순차, 정렬된 배열 이진탐색, 이진 탐색트리에서의 평균, 해쉬 검색 등
    - 상용에서는??

- 삭제 연산? 루트를 삭제 할 땐 왼쪽의 젤 오른쪽이나 오른쪽의 젤 왼쪽을 올리고 비교해서 교환한다!


## 힙 heap

- 키 값이 가장 큰 노드나 가장 작은 노드를 찾기 위해서 만든 완전 이진 트리 자료 구조

- 최대 힙(max heap)
    - 키 값이 가장 큰 노드를 찾기 위한 **완전 이진 트리**
    - 부모 노드 키 값 > 자식 노드의 키 값
    - 루트 노드 : 키값이 가장 큰 노드

- 최소 힙(min heap)
    - 키 값이 가장 작은 노드를 찾기 위한 **완전 이진 트리**
    - 부모 노드 키 값 < 자식 노드의 키 값
    - 루트 노드 : 키값이 가장 작은 노드    

- 삽입 방법
    - 일단 완전이진트리에 해당하는 다음 칸 하나 확장
    - 부모와 비교하며 조건에 맞게 교환  
        ex) 23 추가
        - list 증가
        - 23 삽입
        - 부모 > 자식 확인
        - 부모 < 자식이면 부모가 없거나 부모>자식 까지 자리 교환
    - 예시 코드는 영상참조

- 삭제
    - 힙에서는 루트 노드의 원소를 먼저 삭제하자
    - 루트 노드의 원소를 삭제하여 반환
    - 힙의 종류에 따라 최대 혹은 최솟값 구할 수 있다
    - 완전이진트리를 유지하기 위해 마지막 원소를 루트로 가져오고 교환 진행
    - 코드 확인해봐

</details>


## 강사님 리뷰
- 이진 트리
    - 형제 노드 - 같은 레벨(높이)의 노드들

    - 레벨(높이)는 0부터 시작한다

    - 하나만 있어도 서브트리다

    - 리프 노드 또는 단말 노드는 끝 노드들

    - degree 차수 : 직계 자손의 수
    - 한문장으로 트리를 왜 쓰나요?의 대답 - 로그스케일로 쓰고 싶어서 자료구조를 트리로 했습니다.
    - 이진트리라면 log2N이지만 3발이었다면 log3N
    - 편향된 트리는 로그스케일이 아니다 이득이 없다 트리로 쓸 이유가 없다
    - 즉, 트리는 로그 스케일이 보장이 되어야 - 트리 형태의 구조가 되어야 의미있다
    - 그래서 가장 이상적인 경우가 포화 이진 트리
    - 왜 3발이나 4발을 안 하냐? 규칙성이 복잡해지고 자연적으로 잘 존재하지 않는다?
    - 루트가 1인 이유는 0이면 이슈가 생긴다
    - 포화이진트리는 높이를 알면 노드 수를 알 수 있음. 2^(h+1)-1. 하지만 완전이진트리는 노드 수의 범위만 알 수 있음

- 순회 V L R, L V R, L R V : V만 자리가 바뀌는 것 전중후

- 힙 
    - 완전 이진 트리를 기반으로 log 스케일로 만든 자료 구조
    - 삽입 삭제는 일단 구조에 맞춰 실행하고 규칙에 맞춰 교환한다
    - 최악의 경우 생각해보면 logN인 거 알 수 있음
    - 우선순위 구현은 힙으로 한다
    - 


