# TIL
```
다시 생각해보니까
연결리스트 형태로 구성을 하고
방문으로 박스 생성을 했다면 괜찮았을 거 같다
박스를 생성할 때 동일한 놈이면
우선도 박스를 하나 만들어서 거기다가 저장해야했던 거 같다.
그러면 많이 줄었을듯?
```
## 스터디 기록

## SEA.2112.보호필름

생각보다 많이 돌아갔다.
처음 계획은 BFS였지만 메모리를 많이 잡아먹었고
그래서 DFS로 가지를 쳐보려고 했지만 시간초과가 나왔다.
결국 조합 + 백트래킹으로 구현을 했더니 문제가 없었다.

기본 아이디어는 
변경할 행 조합을 만들어서 전부 1 아니면 전부 0으로 바꿔버리고 체크하기였고
조합은 그냥 불러왔지만
1 아니면 0을 넣는 구조는 연습 겸 비트마스킹 형태로 구현해봤다.

## BOJ.12865. 평범한 배낭

dp연습을 위해서 고른 문제
햄버거 다이어트 문제와 본질적으로 같지만
dp로 풀면서 dp를 이해해보려고 했다. 
아쉬운 건 아직도 어떻게 써야 할 지 모르겠다. 
좀 더 연습해봐야 알 거 같다.

## BOJ.9251.LCS

마찬가지로 dp연습을 위해 골랐다.
일단 처음에 분석을 완전히 잘못해서 같은 연속적인 부분만 체크했는데
틀리고 난 뒤에 다시 분석해보니
일종의 연속적이지 않은 부분이라도 부분수열로 존재할 수 있다면 ok인 것을 알았다.
dp로 구성하면서 어려웠던 점은 위와 왼쪽의 데이터 중 큰 걸 가져와야한다는 점
현재 문자를 제외하고 만들었을 경우의 LCS 길이의 의미라 둘 다 체크해야했다.

## BOJ.1520.내리막길

처음엔 단순 DFS로 접근했는데
시간초과로 인해 계산을 줄일 필요가 있었고
DP로 계산을 줄였다.
기본적으로 지나간 경로에 대한 메모이제이션 형태로 접근하니까
생각한 대로 구현할 수 있었다.

## SEA.14510 나무 높이

1번 생각은 1과 2를 묶어서 2일로 생각해보자
그래서 //3과 %3을 이용해서 정리하려고 했다.

하지만 생각보다 많은 예외를 처리해야하는 부분과
가장 핵심인 부분은 1111 이 남았을 때 121로 처리가 안 되는 부분이었다.

그래서 2번생각으로 1과 2를 따로 세자!
1의 갯수와 2의 갯수를 따로 세서
2가 훨씬 많으면 그걸 1로 나눠주거나 1이 많으면 그걸 2로 합쳐서
1과 2의 크기 차이가 1이 될때 멈추기

여기서 문제는 1111111 같은 케이스가 있을 때
이거조차도 합쳐서 121212 형태로 정리하려고 한다는 점이었다
이건 전부 1씩 따로 처리해야하는 부분이기 때문에 틀렸다.

마지막 3번 생각으로 그럼
처음부터 5 = 122, 7 =1222 식으로 세고 나서 1로 바꾸기
이 경우 초기 1이 많을때만 따로 처리해주면
2가 무조건 많기때문에 앞의 논리가 틀리지 않게 되었다.

## SEA.5686.보물상자 비밀번호

기본적으론 스타트를 가르키는 포인터를 만들어서
원형 돌리면서 한 변에서만 잘라간다는 게 핵심이었다.
문제를 헷갈려서 1시간이라고 적었지만 아마 30분 정도만에 구현했던 거 같다.
조심해야했던 부분은 int(segment, 16)처럼 16진수 처리하는 부분이나
set로 중복을 제외시키는 부분이었다.

## BOJ.1806. 부분합

위에서 헷갈렸던 문제가 이 문제였다.
기록을 따로 해놨는데 풀어보자면

1)start = 0, end = 1로 설정해서 슬라이싱을 계속 해가자
슬라이싱용 인덱스니까 end가 넘어가는 경우 고려해야하니까 numbers+[0]로 만들자.

2) +1씩 하는 조건을 나눠야한다
 end를 부분합이 S가 넘을때까지 +1
넘으면 start를 +1
만약 start == N-1, end == N 이 되면 종료 << 틀렸음

3) 생각해보니 end가 N 이상이 되는 순간 멈춰도 된다. 
왜냐하면 더 큰 부분합을 찾으러 가는건데 더 이상 더할 값이 없을 때가 그떄. << 또 틀렸다(후에 수정)

4) 또 문제 발생 슬라이싱의 시간복잡도가 k여서
O(n^2)이 되는 이유로 시간초과가 발생했다
따라서 슬라이싱을 하지 않고 그냥 현재 합을 계속 갱신해가는 방향으로 수정
슬라이싱용 인덱스를 수정함에 따라 end = 0에서 시작하는 걸로 수정하고 
numbers+[0]을 numbers로 수정

5) 최솟값 비교라 ans = inf로 초기화 했는데 
while 돌입 안하면 inf로 출력되니까 0으로 바꾸는 로직 추가

6) while 조건이 잘못되었다는 사실을 발견
end = N이어도 cur_sum>=S 이면 start를 하나 당겨서 최소인지 확인을 해줘야한다 이 경우를 생각안함
그래서 다시 numbers에 0을 하나 추가하고 N+1일때 멈추게 해서 
인덱스 에러를 방지하고 start를 한 바퀴 더 돌게 했다.

## SEA.4012.요리사

문제 자체는 어렵지 않게 풀었다.
단순하게 N C N//2 콤비네이션을 만들고 
전체 세트에서 콤비네이션 세트를 뺐다.
여기서 포인트는 그냥 콤비네이션을 하면 [1,2,3,4] [5,6,7,8] 과 [5,6,7,8] [1,2,3,4] 2번을 세기 때문에
0을 따로 떼서 붙여주는 걸로 N-1 C N//2 -1 로 반으로 줄여서 계산했다.
그 뒤는 그냥 그 조합 인덱스로 계산을 그대로 구현했다.

다만 이것도 DP로 풀 수 있을 거 같은데 상상이 안 된다..

## BOJ.1916.최소비용 구하기

다익스트라 연습을 하려고 골랐다.
어렵지 않게 구현할 수 있었다.

## BOJ.1068.트리

트리구조의 이해를 위해 시도했다.
기본적인 개념이 어렵진 않았지만
막상 0부터 구성하려고 하니 아직은 삐걱댔다.
다음 시도엔 조금 더 나아지겠지?
