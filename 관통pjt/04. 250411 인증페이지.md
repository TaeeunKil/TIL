# 관통pjt 인증페이지

## AbstractUser

- 과거 Django의 기본 User model과 동일한 모습으로 대체만 한 상황이다

    ```python
    # models.py
    from django.contrib.auth.models import AbstractUser

    class User(AbstractUser):
        pass
    ```

- 필드는 다음과 같다
    
    ![image-27](https://github.com/user-attachments/assets/37787d27-b568-4527-a72a-1d74df513ed0)


    - username 유저 식별용 문자열
    - password 암호화된 비밀번호
    - email, first_name, last_name 프로필 정보
    - is_staff, is_superuser 권한 관련 필드
    - date_joined, last_login 날짜/시간 정보

- 기본 유저를 AbstractUser로 대체하는 이유는 더 많은 사용자 정보를 관리하고 싶어서

- AbstractUser 커스터마이징 사례
    - 프로필 사진이나 주간 독서량, 관심 장르 따위의 정보를 추가해야할 경우
    - 우리는 직접 모델을 확장해야한다

## Model Fields Advanved

- 결국 이것 또한 일반적인 model 확장한 것

    ```python
    class AbstractUser(AbstractBaseUser, PermissionsMixin):
        ...
        username = models.CharField(max_length=150)
        first_name = models.CharField(max_length=150, blank=True)
        last_name = models.CharField(max_length=150, blank=True)
        email = models.EmailField(blank=True)
        is_staff = models.BooleanField()
        is_active = models.BooleanField()
        date_joined = models.DateTimeField()

    ```

### choices 속성

- Model Field의 choices 속성

    - 해당 필드에 선택할 수 있는 (제한된) 값 목록을 지정가능
    ```python
    class Todo(models.Model):
        STATUS_CHOICES = [
            ('TODO', '할 일'),
            ('DOING', '진행 중'),
            ('DONE', '완료'),
        ]

        status = models.CharField(
            max_length=5,
            choices=STATUS_CHOICES,
            default='TODO'
        )
    ```

- 기본 사용법
    - STATUS_CHOICES
        - 튜플 혹은 리스트
        - 'TODO'는 DB에 저장되는 값, '할 일'은 관리자나 FORM에서 표기되는 값
        - [(DB 저장 값, 보기 위한 값),] 구조를 가짐

- 사용 목적

    - 데이터 무결성
        - 특정 필드가 특정 범위 값만을 가질 수 있도록 제약

    - 가독성
        - 직관적인 선택 UI를 제공

- 변수명 정의 하는 법
    - GENDER_CHOICES 처럼 대문자 명명
    - 필수는 아니지만 전형적으로

### choices 속성 실습

#### CharField choices

1. STATUS_CHOICES 리스트 정의
    - DB에는 첫번째 값, Admin이나 form에서는 두번째 값으로 표시

    ```python
    STATUS_CHOICES = [
        ('TODO', '할 일'),
        ('DOING', '진행 중'),
        ('DONE', '완료'),
    ]
    ```

2. 필드 정의

    ```python
    # models.py

    status = models.CharField(
        max_length=5,
        choices=STATUS_CHOICES,
        default='TODO',
        help_text='현재 작업 상태를 선택해주세요.',
        verbose_name='상태',
    )

    ```
    - choices : 미리 정의된 값들만 사용가능하게 STATUS_CHOICES를 연결
    - default : 값 입력 안하면 자동 할당되는 값
    - help_text : Admin이나 Form에서 해당 필드 옆에 간단한 안내문으로 표시되는 설명
    - verbos_name : Admin이나 Form에서 필드의 라벨로 표시될 텍스 (widget인데 html label이 덮어쓴다!!!)

3. Admin Site 결과 확인
    - 새로운 할 일 등록시 출력되는 라벨과 help text를 확인할 수 있음

    ![image-28](https://github.com/user-attachments/assets/35f1e952-c236-4e22-b30f-a7abd6e13148)

    
    ![image-29](https://github.com/user-attachments/assets/09996d65-a659-4550-80e8-46c61f59782e)



#### IntegerField와 choices

1. PRIORITY_CHOICES 리스트 정의
    - DB에는 정수 1, 2, 3이 저장
    - Admin site나 Django Form에서는 '낮음' '보통' '높음' 으로 표시됨
    
    ```python
    PRIORITY_CHOICES = [
        (1, '낮음'),
        (2, '보통'),
        (3, '높음'),
    ]

    priority = models.PositiveIntegerField(
        choices=PRIORITY_CHOICES,
        default=2,
        help_text='우선순위를 선택해주세요 (1=낮음, 2=보통, 3=높음).',
        verbose_name='우선순위',
    )    

    ```

- 정리
    - choices가 DB/Form/UI에 미치는 영향
        - DB에는 키(key) 값만 저장됨 (예: 'DONE', 1)
        - Django Admin/Form에는 라벨 값이 보임 (예: 할 일, 낮음)
    
    - choices를 통해 DB에서는 제한된 값을 저장하고, Form/UI에서는 사용자가 드롭다운으로 편리하게 선택하도록 하며, 무결성과 가독성을 동시에 충족할 수 있음

### PositiveIntegerField

- 0 이상의 정수(양의 정수)만을 저장하기 위한 필드

- SQL 상에서는 일반 정수 타입으로 저장되지만,   
     Django의 유효성 검증과 DB 레벨 제약을 통해     
     음수 값이 들어갈 수 없도록 관리함

- 활용 : 나이, 재고, 포인트, 주간 평균 독서시간 등의 데이터를 저장해야할 때 유용

- 사용 예

    ```python
    class Profile(models.Model):
    age = models.PositiveIntegerField(blank=True, null=True, default=0)
    weekly_avg_reading_time = models.PositiveIntegerField(blank=True, null=True)
    
    # blank, null 옵션 가능
    # default 옵션으로 0 등 지정 가능
    ```
    ```python
    # models.py

    priority = models.PositiveIntegerField(
        choices=PRIORITY_CHOICES,
        default=2,
        help_text='우선순위를 선택해주세요 (1=낮음, 2=보통, 3=높음).',
        verbose_name='우선순위',
    )    

    ```    
    - 데이터 무결성 : db에 애초에 음수 없도록 방지
    - 유효성 검사 : 음수 입력 시 validationerror 발생
    - 가독성/의도 표현 : 우선순위 = 양의 정수임을 모델에서 알려줌

### blank vs null
- 비어 있다는 뜻이지만 동작 레벨이 다르다!

    ![image-30](https://github.com/user-attachments/assets/040d6dbe-4de4-439c-bacc-68922ab74e16)


    - blank는 form validation레벨에서 적용되며, form레벨에서 필수 입력이 아님을 알려줘서 빈 값으로 제출 가능. (유효성 검사에서 통과)

    - null은 DB 레벨에서 적용되며, DB에서 NULL이 저장되도록 설정되는 것(폼 입력에서는 여전히 필수일 수 있음!!!!)

    - blank=True가 자주 쓰이게 될 것


- blank = True 정리
    1. Form 유효성 검사 차원
        - 폼에서 필수 입력이 아니다
        - 해당 필드가 비워져 있어도 검증 에러가 발생하지 않음

    2. DB와는 무관
        - 단지 Django Form이나 admin에서 비워둘 수 있다는 의미
        - DB에는 빈 문자열('')로 저장될 수 있지만 DB가 NULL이 되는 건 아님

- null = True 의미
    1. DB 스키마 레벨
        - 해당 컬럼에 NULL 저장 가능
    
    2. Form 검증과는 별개
        - 즉 NULL 허용해도 FORM에서 공백 제출을 막을 수 있음
    
- 문자열 필드에서의 주의사항
    - 문자열의 경우 null=True를 설정하지 않는 편이 일반적
    - 빈 문자열만으로도 '값이 없음'을 표현할 수 있으므로        
     굳이 NULL 상태와 구분해야하는 상황이 드뭄
    - blank =True만 사용해 '입력해도 되고 안 해도 된다' 가 가능
    - null = True가 있으면 DB에 NULL과 빈 문자열이 모두 존재할 수 있어, 두 상태를 구분할 실익이 없는 한 혼동만 커질 수도 있음

- 결론
    - 필요하지 않다면 null=True는 지양

## Django Forms
- 다양한 필드를 정의했지만 '사용자 입력'을 받으려면 html form이 필요함

- Django Forms을 활용한 이점
    - 필요하다면 modelform을 통해 db까지 손쉽게 연결할 수 있음

### 다양한 Form 정의
- 기본 모델 정의
    ```python
    # models.py
    class Product(models.Model):
        name = models.CharField(max_length=100)
        price = models.DecimalField(max_digits=8, decimal_places=2, default=0.00)
        created_at = models.DateTimeField(auto_now_add=True)
        CATEGORY_CHOICES = [
            ('ELEC', 'Electronics'),
            ('BOOK', 'Books'),
            ('FASH', 'Fashion'),
        ]
        category = models.CharField(
            max_length=20,
            choices=CATEGORY_CHOICES,
        )
    ```

- form1. 일반 Form
    ```python
    # forms.py

    # form1 (일반 Form 예시)
    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField(widget=forms.Textarea)
    ```
    - 지금까지는 {{form.as_p}}로 한번에 출력했지만 개별 렌더링으로도 가능
    ```django
     <div class="accordion-item">
        <h2 class="accordion-header">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree">
            개별 필드 수동 렌더링
          </button>
        </h2>
        <div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#renderingAccordion">
          <div class="accordion-body">
            <form method="post" action="">
              {% csrf_token %}
              <div class="mb-3">
                <label for="{{ form.subject.id_for_label }}" class="form-label">제목</label>
                {{ form.subject }}
                {% if form.subject.errors %}
                  <div class="alert alert-danger">
                    {{ form.subject.errors }}
                  </div>
                {% endif %}
              </div>
              <div class="mb-3">
                <label for="{{ form.message.id_for_label }}" class="form-label">메시지</label>
                {{ form.message }}
                {% if form.message.errors %}
                  <div class="alert alert-danger">
                    {{ form.message.errors }}
                  </div>
                {% endif %}
              </div>
              <button type="submit" class="btn btn-primary">제출</button>
            </form>
          </div>
        </div>
      </div>
    ```

    - 개별 스타일링 가능

- form2. ModelForm
    ```python 
    # forms.py
    # form2 (ModelForm 예시)
    class ProductForm(forms.ModelForm):
        class Meta:
            model = Product
            fields = ['name', 'price', 'category']
    ```

    ```python
    # modles.py
    # Create your models here.
    class Product(models.Model):
        name = models.CharField(max_length=100)
        price = models.DecimalField(max_digits=8, decimal_places=2, default=0.00)
        created_at = models.DateTimeField(auto_now_add=True)
        CATEGORY_CHOICES = [
            ('ELEC', 'Electronics'),
            ('BOOK', 'Books'),
            ('FASH', 'Fashion'),
        ]
        category = models.CharField(
            max_length=20,
            choices=CATEGORY_CHOICES,
        )
    ```
    ![image-33](https://github.com/user-attachments/assets/784764c3-c21c-45d0-96ce-0d9969bd5262)


- form3. Form 상속 (기본이 되는 상속용 폼)
    ```python
    # forms.py, form3

    class BaseForm(forms.Form):
        name = forms.CharField(max_length=50)
        email = forms.EmailField() 
    ```
    ![image-31](https://github.com/user-attachments/assets/d972ae31-0261-4cff-98ba-602de83e073c)


- form4. Form 상속 (상속받아서 쓰는 폼)
    ```python
    # forms.py, form4

    class ExtendedForm(BaseForm):
    address = forms.CharField(max_length=100)
    ````
    ![image-32](https://github.com/user-attachments/assets/f0232384-3890-4398-b3de-f769f3f2fb4c)


- form5. Widget 활용한  form

    ```python
    # forms.py, form5

    class WidgetForm(forms.Form):
        username = forms.CharField(
            widget=forms.TextInput(
                attrs={
                    'class': 'form-control',
                },
            )
        )
        bio = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'rows': 5,
                    'cols': 50,
                    'style': 'resize: none;',
                }
            ),
            required=False,
        )
    ```
    ![image-34](https://github.com/user-attachments/assets/610967ed-ebe6-4f37-ae72-72314a225715)


### MultipleChoiceField

- Django의 폼 필드 중 하나로, 여러 항목을 동시에 선택할 수 있도록 설계
- 예를 들면 카테고리로 책을 분류할 때 과학, 소설 따위로 나눌 수 있음

- HTML 상에서는 \<select multiple>을 사용하거나, 체크박스(CheckboxSelectMultiple) 형태로 가능
- 내부적으로 리스트(파이썬 list) 형태의 선택된 값들을 처리

- choice 필드로 여러 값을 받을 경우 예시
    - 사용자가 red와 blue를 체크하면 view로 넘어오는 폼 데이터는 ['red', 'blue'] 와 같이 전달

    ```python
    from django import forms

    class MyForm(forms.Form):

        FAVORITE_COLORS = [
            ('red', 'Red'),
            ('green', 'Green'),
            ('blue', 'Blue'),
        ]

        # 여러 개의 색상을 선택할 수 있는 MultipleChoiceField입니다.
        # CheckboxSelectMultiple 위젯을 사용하여 체크박스 형태로 표시됩니다.
        colors = forms.MultipleChoiceField(
            choices=FAVORITE_COLORS,
            widget=forms.CheckboxSelectMultiple
        )

    ```

    -  save 로직 수정

    ```python
    # views.py
    
    def form2(request):
    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            product = form.save(commit=False)  # 저장하지 않고 인스턴스 반환
            print(f'cleaned_data: {form.cleaned_data}')  # cleaned_data 확인
            print(
                f'cleaned_data 타입: {type(form.cleaned_data)}'
            )  # cleaned_data 타입 확인
            category_values = form.cleaned_data.get('category', [])
            category_string = ','.join(
                category_values
            )  # 카테고리 데이터를 콤마로 구분된 문자열로 변환
            product.category = category_string
            product.save()
            messages.success(
                request,
                f"제품 '{product.name}'이(가) 성공적으로 저장되었습니다!",
            )
            return redirect('formsapp:form2')
    ```
    
    - 프린트 되는 값

        ![image-35](https://github.com/user-attachments/assets/67801852-a1d4-475d-a69a-64e21f4d1f0e)



    - cleaned_data
        - Django의 Form이나 ModelForm 내부에서,     
         유효성 검사(Validation)을 통과한 폼 데이터가 정리되어저장되는 파이썬 dict 형태의 객체
        - cleande_data는 폼 유효성 검증이 성공했을 때만 존재.
            - form.is_valid()가 True여야 cleande_data에 접근할 수 있음

        - 검증을 통과한 값을 저장하기 전 추가 로직을 수행하려면 활용 가능!!!!

## 관통 프로젝트 안내
