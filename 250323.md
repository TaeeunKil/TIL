# 이주의 문제들

## SEA.1251.하나로

프림 알고리즘 연습을 할 수 있었다.
어렵지 않게 구현 가능했지만
아직 방문 조건 구현이 반대가 되는 이유를 모르겠다

## SEA.1249.보급로

이전에 백트래킹으로 구현했던 걸
다익스트라로 구현했다.
처음에 좀 헤맸는데
차근차근 구현하니 바로 풀 수 있었다.

## BOJ.1325.효율적인 해킹

DP로 구현해보려고 했는데 실패했다.
문제 구조상 사이클이 있을 수 없다고 생각했는데
그런 게 존재하는, 즉 트리 형태로 구성하기 힘든 모양이었던 것 같다.
그래서 헤매다가 정석대로 모든 케이스에서 BFS 돌면서 풀었다.
하지만 더 줄일 수 있을 것 같긴 하다.
한 번 BFS로 계산한 걸 가져다 쓸 수 있을 거 같다.

## BOJ. 14891.톱니바퀴

이 문제를 봤을 때 원본을 바꾸는 게 아닌
포인터를 활용하고 싶었다.
그래서 포인터를 3개 만들어서 써봤는데
너무 어지럽게 표현이 되어서 조금 익숙해져야할 거 같다.
포인터는 반대로 돌아야한다는 것도 하고 나서야 눈치챘다.
또 디버깅이 좀 힘들었다. 

별개로 진짜 로테이션은 deque.rotate(n)으로 구현가능한 걸 알게되었고
또 전파하는 과정이 큐 느낌이 나서 큐를 사용했는데
이정도 크기에선 그냥 for문으로 전파하는 게 맞았던 거 같다.

## BOJ.2146.다리만들기

2가지 함수로 나눠서 
1) 섬 그룹으로 묶어서 바꾸는 bfs + 테두리 그룹 만들기
2) 각 테두리 그룹에서 다른 그룹으로 가는 bfs - 최소 거리 갱신
이렇게 구성했다.
디버깅 했던 부분은 같은 그룹을 만났을 때 탈출하는 부분이었다.

## BOJ.1339.단어수학

가중치가 있는 딕셔너리 제작한 부분과
거꾸로 읽어가면서 0~9 배치하기까진 확실히 생각해냈다.
이후엔 gpt로 복기했는데
키를 기준으로 키순대로 정렬하는 것이 key=lambda x: x[1]로 가능한 것과
letter_weight.get(char, 0)으로 없으면 0 나오게 가능 한 것을 얻었다.

## BOJ.17472.다리 만들기 2

행렬 형태의 맵을 받았을 때
이걸 가중치가 있는 그래프로 다시 변형을 하고
그걸 프림을 통해 MST을 찾아 가중치의 합을 구했다.
핵심이었던 가중치 계산은 행과 열을 돌아서  0이 아니면 0 카운터를 세는 느낌으로 구현했다.

## BOJ.2042.구간 합 구하기

세그먼트 트리를 연습했다.
이 경우 탑-다운 형태가 아니라 바텀-업으로 구성해봤는데
쿼리를 구현하는 게 조금 이해가 안 됐다.
양쪽을 올려서 노드를 찾아가는 과정을 홀짝으로 구현했는데
처음에는 이해가 잘 안 되어서
따로 찾아보고 이해할 수 있었다.

## BOJ.10999.구간 합 구하기2

윗 문제에서 크게 다르지 않다고 생각해서 쉽다고 생각했지만
해당 크기에서는 불가능한 생각이었다.
하나하나를 계속 업데이트 하는 건 시간이 너무 오래 걸렸고
이렇게 동시에 업데이트를 하는 경우에는
전파 또한 변화를 누적해서 동시에 하는 게 맞았다
다만 내가 바텀-업으로 구성했던 코드에서 시작해서 하려고 하니
생각보다 아주 힘들었었다.
그래서 GPT의 도움을 많이 받았다.
탑-다운으로 다시 풀어봐야할 거 같다.
