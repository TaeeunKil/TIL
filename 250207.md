# TIL

## 수업 요약

<details>
<summary>필기니까 접어놓기</summary>

### 2-dimensional list 이차원 배열  
 - [[0] * 4] * 3 형태로 선언 하지 마라. 조작하면 문제생김  
  왜? 참조를 3번 반복하는 형태  
  [[0]*4 for _ in range(3)] 으로 선언해야한다
  
- 지그재그 순회?  
  if else로 구현도 가능하지만   
  인덱스를 j+(m-1-2* j)*(i%2) 따위로 조절 가능

- 델타를 이용한 2차원 배열 탐색   
  탐색할 인덱스 방향에 따라 더할 값 리스트를 만든다   
di = [0, 1, 0, -1]  
dj = [1, 0, -1, 0]  
강사님 규칙은 오른쪽 방향에서 시계방향으로 순서 

- 경계조건의 경우,  
  if 0<=ni<N and 0<=nj<N:   
  형태일 때만 발동하게 구성하면 된다

- 범위가 길어질거면 + 하지말고  
for a in range(1,1+N) 하고 di dj에 a를 곱해라.  

- 2차원 탐색을 할때   
  dir = [[0.1], [1,0], [0,-1], [-1,0]] 따위로 만들어서   
  for di, dj in dir:  
  를 만들고 i, j에 대해 더해서 새로운 new_i, new_j를 만들어서 처리 

### Subset Sum 부분집합의 합 문제

- 집합의 부분집합 중에 그 집합의 원소를 모두 더한 값이 0이 있는가 묻는 문제

- 완전검색으로 풀어보려고 하는 것 - 부분집합 전부 생성해보기

- 부분집합의 수 = 원소가 n일떄 2^n  
  왜? 한 원소가 포함 or 포함하지 않음 2가지 선택지가 있어서  
  원소갯수 n번 곱하기

- bit란 새로운 리스트로 포함 여부를 표현  
  [1, 2, 3]의 경우, bit는 [0, 0, 0] 부터 [1, 1, 1]까지 가능하고   
  이를 만들 수 있으면 여기서부터 부분집합을 역으로 만들어낼 수 있다

- bit를 만드는 방법?
  ```python  
  a = [1, 2, 3]
  A = 3
  bit = [0, 0, 0]

  for i in range(2):    
    bit[0] = i  
    for j in range(2):  
      bit[1] = j  
      for k in range(2):  
        bit[2] = k

  for b in range(A):
    if bit[b]:
      print(a[b])
  ```
  로 구현 가능  
  핵심은 if bit[i]로 0일때는 제외하고 1일떄 발동

### 비트 연산자

- 비트 연산자
  ```   
  & : 비트 and   
  | : 비트 or    
  << : 피연산자의 비트 열을 왼쪽으로 이동시킨다    
  >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다
  ```

- 1 << n : 2^n 즉 원소가 n개일 때 모든 부분집합의 수
- i & (1 << j ) : i의 j번째 비트가 1인지 아닌지를 검사

- 따라서 bit 생성해서 부분집합을 쉽게 만드는 법 
  ```python
  arr = [1, 2, 3]
  n = len(arr) 
  
  for i in range(1<<n): # 1<<n 부분집합의 갯수 2^n
    for j in range(n):  # 원소의 수만큼 비트를 비교
      if i & (1<<j):    #  i의 j번 비트가 1인 경우
        print(arr[j], end=", ") # j번의 원소를 출력
    print()
  print()
  ```

  






</details>

## 강사님 리뷰

- 농작물 풀이 - 직관적으로 중간부터 3칸으로도 구현 가능 인덱스의 합이 일정 이하로 조건을 주는

### 순열과 조합

- 순열
  본인을 다시 뽑는 불상사만 제외!

- 조합  
  [1, 2, 3] 이 있다고 치고 2개의 조합을 뽑으면
  본능적으로 직관적으로 생각 과정을 팔로잉해보자  
  기본적으로 1를 뽑고 생각한다. 
  그 다음에 남아있는 2를 뽑는다. - 하나 체크  
  다 뽑았으면 2를 제거하고 돌아가서 안 뽑힌 걸 체크한다
  3이 있으니까 또 뽑는다 - 하나 체크
  그 다음에는 다 뽑았으니까 1까지 없애는 데로 돌아간다
  그럼 1이 완료되었다
  다음 2를 뽑는다.
  
  즉 굳이 앞에 걸 체크하지 않는다!


## 문제풀이

- 역순으로 for 문 돌릴 거면 for a in reversed(some):
이렇게 하자
