# TIL
## 수업 요약
- private
- 
## 강사님 리뷰
- 해쉬 복습  
  키 -> hash function -> 주소
  O(1), 기본적으로 다대일, 해시충돌, 메모리를 아주 많이 먹는다

- 비교 연산 - 탐색범위가 1개씩 줄어듬   
  이진 검색 - 탐색범위가 반씩 줄어듬

- 100만쯤 되는 탐색 하니까 0.05초 정도 걸림 FOR N으로 하면 이진은 0

- 이진 탐색은 정렬이 필요하다 그래서 보통 정렬포함하면 O(NlogN)이라 O(n)보다 느릴 수 있다.

- 하지만 여러번 하는 경우? 정렬은 한 번만 포함이라 이득. 즉 한 번만 검색할거면 N으로 갈만하다

- 면접에서 묻는다 데이터 주면서 검색해보세요  
  1. 정렬 되어있나요? 2. 조회하는 수는 얼마나 되나요?  
  그러면 초기비용이 들더라도 이진 검색을 하겠다 or 그냥 순차 검색하겠다

- counting 정렬(계수정렬) 숫자 세서 누적합으로 거꾸로 돌면서 정렬 - 안정정렬을 위해

- 셀렉션 알고리즘? 선택정렬의 응용이다.

- 2a 2b 1 4 3
버블 1회차  2a 2b 1 4 3 / 2a 1 2b 4 3 / 2a 1 2b 3 4
이걸 4회차까지 하는데 각 회차마다 0~k회의 스왑이 일어난다

선택 1회차 구간내 최솟값 찾아서 스왑한다. 여기선 1회지만 최솟값일 수 있으니까 0~1회 스왑으로 고정
2회차 1 2b 2a 4 3 스왑 0
3회차 1 2b 2a 4 3 스왑 0
4회차 1 2b 2a 3 4 스왑 1

즉 불안정정렬이다

### 부분집합
- 비트 연산자 배우기
- {1,2,3}의 부분집합?
- 당연히 조합을 배웠으니 그걸 통해서 3C0 3C1 3C2 3C3으로 구현가능
- 하지만 새로운 방식으로 접근
- 0or1 0or2 0or3 의 모든 경우의 수 -> 2**3
- 기본 골자는 이렇다
```python
numbers = [i for i in range(1, 5)]
visited = [0]*len(numbers)


def subset(c):
    if c == len(numbers): #visited가 전부 찼을 때? 각 요소가 전부 들어갈지 말지 의사 결정이 끝났다면
        for i in range(len(numbers)):
            if visited[i] == 1:
                print(numbers[i], end=" ")
        print()
        
        return
    
    visited[c] = 1
    subset(c+1)
    visited[c] = 0
    subset(c+1)
    #두 갈래길 진행하는 그래프 형태의 재귀형태
    
```
- 이걸 비트 연산자로 표현?
- 1<<n 은 100000(2) 이진수의 표현으로 2**n    
  for i in range(1<<n) 만으로도 000001, 0000010 이런 걸 전부 표현한 거  
  즉 부분집합 on/off 구현
- 비트 연산 &는 교집합 1일떄만 1
- (1<<j)는 for j in range(j)로 구성하면 1 10 100 1000 10000으로 표현되고  
   i &(1<<j)는 그래서 각 자리에 1이 있니? 묻는 걸로 이해하면 되고  
  그 자리에 있으면 배열인덱스로 출력하는 것으로 마무리  


- 조합으로?
- 우리가 프린트 한 부분 수정이 필요하다

```

def comb(cnt, idx):
    print(answer) #프린트 위치 중
    if cnt == len(numbers): #이전엔 M이었는데 복구
        return
    
    for i in range(idx, len(numbers)):
        answer.append(numbers[i])
        comb(cnt+1, i+1)
        answer.pop()
```

## BAJ.2805.나무자르기
- 숫자가 커서 완전탐색이 불가능함
- 이진 검색을 구현해야만 하는 문제
- M값이 아닌 높이의 값으로 찾아야가야하고  
  배열의 인덱스가 아닌 숫자의 크기라는 점을 조심
- 부등식이 같을 떄를 조심해야함
- 왜 그런지는 모르겠는데 같을 때 결과를 계속 업데이트 했다.  
  베이스라인을 뱉으니까 틀림

