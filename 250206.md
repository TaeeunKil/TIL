# TIL


## 수업요약

<details>
<summary>필기니까 접어놓기</summary>

<!-- summary 아래 한칸 공백 두어야함 -->

### 어제 리뷰
- 버블 정렬  
  ```python
  def BubbleSort(a, N) : 	# 정렬할 List, N 원소 수
    for i in range(N-1, 0, -1) : # 범위의 끝 위치
        for j in range(i) :		# 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1] :
                a[j], a[j+1] = a[j+1], a[j]
  ```
  횟수에 대한 for문이 가장 바깥에 (N-1, 0, -1)로 존재함

- gravity
  ``` python
  '''
  9
  7 4 2 0 0 6 0 7 0
  => 7
  9
  4 2 0 0 7 6 0 7 0
  => 5
  '''
  
  N = int(input())
  box = list(map(int, input().split()))
  
  max_v = 0
  for i in range(N-1):
      cnt = 0         # i박스 오른쪽(i+1~N-1)에 더 낮은 박스 개수 (낙차)
      for j in range(i+1, N):
          if box[i] > box[j]:
              cnt += 1    # 더 낮은 박스면 낙차 추가
      if max_v < cnt:
          max_v = cnt
  print(max_v)
  ```    

### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 해  
  **선형 시간에 정렬하는 효율적인 알고리즘**
- 제한 사항
  - 정수나 정수로 표현 가능한 자료에 대해서만 가능(인덱스를 활용)
  - 카운트를 위한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도 : O(n+k) n은 len(list), k는 max of 정수

- 만드는 법
  1. 인덱스 = 리스트의 값, 밸류 = 그 값의 갯수의 개념으로 새로운 count 리스트를 만들기 #길이는 max(list)+1
  2. 누적합의 형태로 count 리스트를 바꾼다 (위치 정보로 변형)
  3. 원래 리스트에서 거꾸로 훑으면서 그 밸류의 count 리스트의 밸류에 해당하는 번째에 넣고 -1
  
  예를 들어, 001233344 형태로 정렬하고 싶은 012433043 따위의 리스트가 있다면
  [2, 1, 3, 2]의 새 리스트를 만들고
  [2, 3, 7, 9]로 변형 한 뒤에
  012433043을 뒤에서부터 순회하며 해당하는 밸류의 인덱스의 값을 받아
  새 리스트에 넣는다. 그 값의 -1의 인덱스에 해당하는 곳에.

- 왜 2, 1 ,3 ,2에서 바로 제작하지 않는가??  
  안정정렬을 하려고! 같은 값이여도 뒤에 있는 값이 뒤에 적히게

### 완전 검색
- Baby-gin Game  
  0~9 숫자 카드가 있고 임의의 카드 6장을 뽑았을 때  
  3장의 카드가 연속적일 경우 run  
  3장의 카드가 같을 경우 triplet  
  6장의 카드가 run triplet으로만 구성되면 baby-gin   
  6자리 숫자를 받아 baby-gin 판단하는 프로그램 작성해봐
  
- Exaustive Search 완전 검색  
  가능한 모든 경우의 수를 나열해서 확인하는 기법  
  Brute-force 혹은 generate-and-test 기법이라고도 불린다
  경우의 수가 작을 때 유용  
  수행 속도는 느리고 해답을 찾아내지 못할 확률이 작다  

- 고려할 수 있는 모든 경우의 수 생성하고 테스트
  
- Permutation 순열
  - nPr 서로 다른 것들 중 한 줄로 나열하는 것
  - n!/(n-r)!
  ```python
  arr = [2, 3, 7]
  for i1 in range(3):
    for i2 in range(3):
      if i2 != i1:
        for i3 in range(3):
          if i3 != i1 and i3 != i2:
            print(arr[i1], arr[i2], arr[i3])
  ```
  - for문 구현은 n이 커지면 for*n이 되어야함



### Greedy 탐욕 알고리즘 
- 최적해를 구하는 데 사용하는 근시안적인 방법  
  그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식  
  하지만 각 지역적으로는 최적이어도 그 최종적인 최적이라는 보장은?  

- 거스름돈 문제?
- Baby-gin greedy 구현
  ```python
  num = 456789 #6자리 수
  c = [0]*12 #카운트 리스트

  for _ in range(6):
    c[num%10]+=1 #1의 자리를 알아낸 연산
    num//=10     #1의 자리를 제거한 연산
  
  i = 0
  tri = run = 0

  while i < 10:
    if c[i] >=3 #triplet 조사 후 데이터 삭제
      c[i] -= 3
      tri +=1
      continue #같은 자리 한 번 더 볼 수 있다 while로 돌아감
    if c[i] >=1 and c[i+1] >= 1 and c[i+2] >=1 :
    # run 조사 후 데이터 삭제
    # c를 12까지 만든 이유. 더미 2칸을 더 넣어서 인덱스 오류 방지
    # 오류 방지용 조건을 추가하거나 한 줄 늘리는 것보다 간단한 방법
      c[i] -= 1
      c[i+1] -= 1
      c[i+2] -= 1
      run += 1
      continue
    i+=1

  if run + tri ==2 :
    print('baby-gin')
  else:
    print('lose')
  ```
- 자주 실수하는 오답 정렬  
- 이 경우는 123123을 112233으로 바꿔서 알 수 없다  
 

</details>

## 강사님 리뷰
- 취업 방향을 정하고 싶다면 직무와 규모의 우선을 정하자  
  규모가 우선이면 직무와 상관없이 다 집어넣어보기  

  자격증?  
  어학 우선 - 토스 오픽 IM1 이상 3일 공부해  
  정처기 - 공/은/규모작은 국가산업  집어넣을때 좋음  
  빅분
  ADSP SQLD 필요X 시간남으면 공백기에 도전

- 카운팅정렬 == 계수정렬  
  안정정렬이어야하는 이유?  안정정렬이어야 카운팅 정렬 개념  
  누적인 이유?  
  1 3 1 1 2의 카운팅 정보는 차지하는 칸 수  
  1 4 5 6 8의 누적합 정보는 정렬 후 차지하는 칸이 끝나는 인덱스  

- 시간 복잡도는 항상 최악을 생각한다  
  O(n+k)인 이유는 둘 중 누가 클 지 몰라서  

- 정렬은 개념적으로 이해하고 손 구현은 나중에 면접시험 전에 보기  

- log2 N = 2의 지수에 넣으면 N이 되는 값 = 2를 몇 번 곱해야 N이 나오니    
  1 ~ 100 절반 51 ~ 100 절반 76 ~ 100 절반 ... 한칸 100 끝  
  이면 반대로 뒤로 간다고 생각해서 2 몇번?  

- Greedy는 수학에 가깝고 구현에 사용하지 않는다 -> 코딩테스트에 자주 안 나옴

  
## SWEA.23231.전기버스
- Greedy로 while 검사하기로 구현했는데  
  break 정확하게 하는 것과  
  그것이 되기 위한 조건을 역추적 하는 과정에서  
  디버깅 하는 실력을 향상시킬 수 있었다.




## SWEA.22980.삼각형만들기

- 일단 삼각형이 존재하지 않는 조건에서 가장 긴 변은 유일하게 존재한다 증명  
  삼각형 증명 부등식을 삼각형이 존재하지 않는 부등식으로 만들면  
  X < Y+Z에서  X >= Y+Z가 되고 만약 긴 변과 같은 변이 있다면 (X = Y)  
  0 >= Z 가 되어 불가능  
  이제 X가 가장 클 때 Y가 가장 클 때 Z가 가장 클 때 3가지 기준을 세울 수 있다.    

- 가장 긴 막대에 대한 삼각형불가능 조건 구하기
  
  X >= Y + Z 양 변에 X를 더한다. 왜? X+Y+Z 형태는 3가지 조건에 다 일반적으로 쓸 수 있으니까.  
  2X >= X + Y + Z 임을 알 수 있다.  
  X = A+a, Y = B+b, Z = C+c 이고 이를 대입해서 정리하면   
  2(A+a) >= A+B+C+a+b+c 이고 초기 변 길이의 합을 S0, 변화량을 d로 두면  
  2(A+a) >= S0 + d  
  #S0 = A+B+C, d = a+b+c  

  X변 관점으로 조금 변경해보면
  d = a+b+c니까 a를 더하고 남은 r=b+c로  
  2A+a >= S0 + r  
  r <= a+2A-S0  
  여기서 2A-S0 = A-B-C 로 초기 조건에서 A가 길 때 검증조건 부분이다.
  이걸 D라 두면
  r <= a+D 이 조건이 X로 인해 삼각형을 만들 수 없는 경우다.  

  말로 설명을 하면 x변에 a를 더해서 가장 긴 변이 되었는데  
  만약 나머지 변들에 더할 값이 a+D 보다 작거나 같으면  
  가장 긴 변이 너무 길어서 다른 두 막대의 길이에 더하는 값이 따라가지 못한다.  

  또 a+b+c <= K에서 r<= K-a이므로 두 조건을 합쳐보면 
  즉 r <= min(K-a, a+D)이고 조건으로부터 r>=0   

  a+D는 음수일 수 없다 a>=-D, 만약 -D가 0보다 작으면 a>=0이어야 한다.  
  a >= max(0, -D) 

- 불가능한 경우의 수 공식  

  a 선택의 수는 max(0,-D) = M ~ K  
  
  r 선택의 수는 0 ~ min(K-a, a+D) = R(a)  
  
  r이 정해졌을 때 b+c의 경우의 수 (r+1)  

  수식으로 정리해보면    
   $\displaystyle\sum_{a=M}^{K} \sum_{r=0}^{R(a)}{(r+1)}$  
  
  여기서 내부합은    
   $\displaystyle\sum_{r=0}^{R}{(r+1)}=\frac{(R+1)(R+2)}2$  

  이제 R(a) = min(K-a, a+D)를 해체할 시간  
  여기서 중요한 구간은 K-a = a+D가 되는 a = (K-D)/2 를 기준으로 나누기  
  M <= a <= K 인 상황  

  1) M <= a <= (K-D)/2  
  중간 기준 작거나 같은 구간, K쪽이 크니까 D쪽이 작은 값  
  R(a) = a + D    
  내부합 S1 = (a+D+1)(a+D+2)/2  


  2) (K-D)/2 +1 <= a <= K  
  중간 기준 크거나 같은 구간, D쪽이 크니까 K쪽이 작은 값  
  R(a) = K-a  
  내부합 S2 = (K-a+1)(K-a+2)/2  

  즉   
  $\displaystyle \sum_{a=M}^{K} S(a) = \sum_{a=M}^{(K-D)/2}S_1 + \sum_{a=(K-D)/2}^{K}S_2 = \sum_{a=M}^{(K-D)/2} \frac{(a+D+1)(a+D+2)}2 + \sum_{a=(K-D)/2}^{K}\frac{(K-a+1)(K-a+2)}2$

  로 표현 가능하고 이건 닫힌식으로 계산이 가능하다.

- x, y z 각각의 변에 대해 이 값들을 계산하는 코드를 짜서 각각의 삼각형불가능 경우의 수 n1 n2 n3을 구해 더하고
  
- 이를 total - n1 - n2 -n3 하면 된다.

- 코딩화 생겼던 문제들
  - 









  





  
