# TIL

## 수업
<details>
<summary> 수업 요약 </summary>

## 선형 큐
- 스택과 마찬가지로 삽입 삭제의 위치가 제한적인 자료구조

- FIFO(First In First Out) 선입선출구조

- Front 머리 Rear 꼬리, enQueue 삽입 deQueue 삭제
(push pop은 스택에 쓰자)

- isEmpty() 공백인가? 공백이면 꺼내지 말기    
isFull() 포화인가? 포화면 넣지 말기
Qpee() front에서 삭제 없이 확인하기

- 우리는 큐를 만들고 front = rear = -1 인덱스 정의    
 삽입하면 rear 1개 증가하고 거기에 저장시키기  
 삭제하면 front 1개 증가시키고 거기 있는 거 빼내기.     

- front == rear면 비어있다    
 front == rear == -1이면 초기상태     
 rear == n-1이면 포화상태

## 원형 큐
- 선형 큐의 경우 배열의 앞에 활용할 공간이 있어도 포화로 잘못 인식할 수 있다.   
 해결하려고 매 연산마다 배열의 앞으로 모두 이동시킨다면 효율이 급격히 떨어짐

- 그래서 원형처럼 다루는 큐처럼 다루는 방법으로 해결

- 초기상태 공백 - front = rear = 0

- index가 순환해야함. n-1 가리킨 후 그 다음 배열의 처음으로 0으로 와야한다 - 나머지 연산!

- 즉 삽입/삭제 위치가 +1이 아니라 +1한 것을 n으로 나눈 나머지

- front == rear : 공백상태  
(rear+1)%n == front : 포화상태, 삽입할 다음 rear 위치 == front

## 연결 큐

- 단순 연결 리스트(Linked List)
  - 큐의 원소 : 단순 연결 리스트의 노드
  - 큐의 원소 순서 : 노드의 연결 순서. 링크로 연결되어 있음
  - front : 첫 번째 노드 링크
  - rear : 마지막 노드 링크

- 상태 표현
  - 초기 상태 : front = rear = null
  - 공백 상태 : front = rear = null

- 가리키는 레퍼런스를 표현?
https://wikidocs.net/224937

- 삽입 삭제가 편하다

## Priority Queue 우선순위 큐

- 특성
    - 우선 순위를 가진 항목들을 저장하는 큐
    - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나간다

- 우선순위 큐의 적용 분야
    - 시뮬레이션
    - 네트워크 트래픽
    - 운영체제의 테스크 스케줄링

- 배열을 이용해 구현한다면 원소 삽입 과정에 우선순위 비교해 삽입하는 구조. 문제는 이에 소요되는 시간 메모리 낭비가 큼

## Buffer 버퍼
- 데이터를 전송하는 동안 그 데이터를 일시적으로 보관하는 메모리 영역
- 버퍼링 : 버퍼를 활용하는 방식 혹은 버퍼를 채우는 동작

- 자료구조
    - 일반적으로 입출력 및 네트워크와 관련된 기능에서 활용
    - 순서대로 입/출/전달 해야하므로 FIFO의 큐를 활용한다.

- sys.stdin = open('input.txt', 'r') 를 해석하면 keyboard의 버퍼에서 받아오는 콘솔 입력을 standard in으로 바꿔버리는 것

  
</details>

## 강사님 리뷰

- 개념체와 구현체의 구분
- 개념은 큐, 구현체는 선형큐 원형큐 연결큐
- 리스트 vs 연결리스트
  - 리스트는 이어붙이다보니 메모리 공간을 넘어가는 순간 새로 복사함(낭비). 
    대신 참조에 유리 (인덱스 참조는 칸수와 관련)  
    중간과 처음 삭제의 경우 리스트는 재배치를 해야해서 불리  
    근데 끝 삭제의 경우는 유리할 수도? 연결리스트의 끝포인트가 없으면 모든 연결관계 다 봐야해서
  - 연결리스트는 메모리 공간 한칸만 먹으면서 연결관계를 남겨서 낭비가 없음  
    대신 참조에 불리 (연결관계를 다 타고가야함)  
    삭제의 경우 연결 정보의 변경 혹은 포인트 변경만 하면 됨  
    ![image](https://github.com/user-attachments/assets/fff55119-1e17-45a4-865a-e01063cfd196)

- 즉 큐를 쓸 때 삽입/삭제가 빈번하면 연결리스트. 참조가 빈번하면 리스트가 좋음

- 자료구조에 대해 생각할떈 항상 CRUD에 대해 생각해라
  - 생성 읽기 업뎃 삭제

- 버퍼를 쓰는 이유?
 - 실시간 방송 
  - 서버에 보낸 데이터를 인터넷(http 프로토콜)을 통해 전송해 개인브라우저에서 해석
  - 규약과 정보를 프레임과 같이 보내는데 모든 프레임마다 하면 쓰읍...
  - 그럼 프레임 다발을 특정 구간마다 엮어서 보내자!
  - 서버의 버퍼에 저장하다가 버퍼가 차면 개인한테 보내면 된다
  - 개인의 버퍼에 그 정보가 충분히 차면 재생
  - 즉 버퍼링은 두 쪽 중에 한쪽의 버퍼가 덜 찬 이슈
 - 또 다른 경우
  - pc에 입력을 주는 키보드를 생각해보자
  - pc의 처리속도는 아주 빠르기 때문에 모든 순간을 체크하는 게 아니라 주기적으로 버퍼를 확인해서 처리
  - 키보드의 입력을 버퍼에 저장해서 그 주기마다 처리
  - 즉 위에서처럼 일부 저장을 위해서가 아니라 속도의 동기화를 위한 행위



## CRLF? LF?
- Carriage Return(CR) (\r)  
  캐리지를 리턴한다.  
  타자기를 쓸 때 움직이던 걸 앞으로 보내던 행위로 커서를 라인 앞쪽으로 보내는 것

- Line Feed(LF) (\n)  
  커서는 그대로 있고 종이만 올린다. 줄을 바꾼다.

- 우리가 쓰는 ENTER = CRLF다.
- 코딩할 때 조심해야하는 건 운영체제 별로 이게 다르다. 윈도우 = CRLF, UNIX or Mac = LF다.
- 여러 곳에서 작업한다면 IDE 우측 아래 CRLF, LF 확인해라
- CRLF = \r\n으로 4바이트, LF = \n 2바이
