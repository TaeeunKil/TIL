# TIL
# 수업

## 비트 연산
- 1 bit : 0과 1의 표현단위
- 1 Byte : 8 bit 묶어서
- AND, OR
    - a AND b : a, b 둘 다 1일때만 결과가 1이다 그 외에는 0
    - a OR b : a,b 둘 다 0일떄만 결과가 0이다 그 외에는 1
    - 파이썬에선 &, |로 int를 연산하면 자동 2진수 계산.
        - ex     
        7&5 = 111&101 = 101 = 5     
        7|5 = 111|101 = 111 = 7

- 파이썬에서 2진수 16진수 10진수 변환하기
    - bin(10) = 0b1010, hex(10) = 0xa
    - int('1011', 2) = 11, int('b', 16) = 11

- 2진수 자리가 다르면? 1000000 & 1111은 1000000 & 0001111 로 볼 수 있다. 0을 채워넣어라.

- 16진수에서 2진수는 쉽다. 16진수의 한자리를 4bit로 바꾸면 된다.


- XOR
    - 같으면 0 다르면 1
    - 파이썬에선 ^
    - 어떤 값이던 같은 수로 2회 XOR하면 원래 수로 돌아온다.
    - 암호화에도 사용 가능 - 특정 key를 알면 XOR로 암호화, XOR 또 해서 복호화

- Shift 연산자
    - Left: bits << 숫자
    - Right: bits >> 숫자
    - 특정 수 만큼 비트를 밀어라
    - 의미는 왼쪽으로 민다 = 2배 늘린다
    - 오른쪽으로 민다 = 2로 나눈 몫


- 응용
    - 1 << n = 2^n
    - 부분집합의 수 구하기 = 안쓰거나 쓰거나 0,1로 생각하면 경우의 수 1 << n
    - i &(1 << n)로 1인지 아닌지 확인하는 걸로(부분집합 만들기 따위) 활용가능
    ```python
    arr = [1, 2, 3, 4]
    for i in range(1 << len(arr)):
        for idx in range(len(arr)):
            # 1<< idx : 1 10 100 1000
            # i의 idx번째 bit가 1인지 확인(부분집합에 포함되어있는지 확인)
            if i &(1<<idx):
                print(arr[idx], end=' ')

    #응용 합이 10인 부분 집합만 출력해라
    for i in range(1 << len(arr)):
        subset = []
        total = 0
        for idx in range(len(arr)):
            subset.append(arr[idx])
            total += arr[idx]
            if i &(1<<idx):
                print(f'부분집합 : {subset}')
    ```

- 음수 표현 방법
    - 컴퓨터는 음수를 2의 보수로 관리한다.
    - 맨 앞자리 bit(MSB)는 음수 or 양수를 구분하는 비트이다.
    0. 최초 컴퓨터는 연산이 느리고 효율적으로 구현해야해서 뺄셈을 안 씀
    1. 부호 비트만 사용했더니 숫자는 표현 가능한데 연산자 사용 시 문제 발생
    2. 1의 보수가 등장
        - 각 비트를 뒤집어서 표현하자.
        - 0을 표현하는 방법이 0000 0000, 1111 1111 2가지가 되어버렸음
    3. 2의 보수
        - 각 비트를 뒤집고 1을 더하자!
        - 혹시 덧셈 연산 시 over되면 삭제
        - 맨 앞자리가 1이면 음수기 때문에 부호비트 1개랑 7개의 값으로 저장(1바이트 기준)
        - 2의 보수를 취한 수를 한 번 더 취하면 **원래의 값으로 돌아온다**


- bitwise NOT 연산자
    - 0이면 1, 1이면 0
    - 파이썬에선 ~
    - ~4는 -5다. 왜? 
        - 0100 = 4(양수이므로 앞에 0 하나 있음) 
        - 뒤집으면 1011
        - 부호인 맨 앞 빼고 2의 보수 취하면 100+1 = 101 이므로 -5

## 실수
- t = 3.141592
- f-string으로 표현하기 {t2}
- 소수점 둘째자리까지 출력(반올림) {t2:.2f}
- 파이썬에서 실수 표현 범위는 아주 넓다 다른 언어와 다름
- c 언어에선 4바이트 - 32비트 - 1비트는 부호니까 2의 31승 = 42억 - 음수~양수니까 -21억~21억 표현 가능
- 최대값 1.8*10^308 이 이상은 inf
- 최솟값 5.0*10^-324 이 이하는 0
- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다. 이 떄 작은 오차가 생겨 **계산에서 다른 결과가 되기도 함**
- 0.1 + 0.1 + 0.1 == 0.3 아니다! (부동소수점 오류)
- 반올림 혹은 버림 계산을 잘 활용해라 소수점 계산 하지마!
- 소수점의 2진수화?? 
    - 2를 나눠서 몫으로 했던것과 비슷
    - 소수점 아래의 값에 2를 곱하고 나온 1의 자리를 2진수화 한 곳 소수점 아래에 붙여넣기.
    - 남은 소수점 아래의 값에서 반복
- 부동 소수점 표기법을 사용한다. IEEE 754라는 컴퓨터에서 부동 소수점을 표기하는 국제 표준
- 소수점의 위치를 고정시켜 표현하는 방식
- 1001.0011 = 1.0010011 *2^3
- 32비트 기준 부호 1비트/지수8비트/가수23비트
    - 부호는 0이면 양수 1이면 음수
    - exponent 지수부 : 부동소수점의 크기, bias값
    - mantissa 가수부 : 실질 수
    - bias는 지수의 양수 음수 표현을 위한 것

아무튼 컴퓨터는 실수를 근사적으로 표현하니 항상 조심할 것


# 강사님 리뷰

## 비트연산
- 음수를 표현하는 방법은 2의 보수(1의 보수도 있음)
- 1의 보수의 단점은 0의 표현이 111 000 2개가 되어버린다
- 부호 표현 비트 MSB 기억해라
- 시프트 연산에서 MSB는 같은 값으로 유지가 된다
    - ?? 잘 모르곘음 검색해보자.
- 파이썬의 동적으로 바꾸는 메모리에선 무조건 유지지만, 다른 언어의 경우 부호가 바뀔 수도 있다.

## 소수
- 무한 소수를 메모리가 한정적인 컴퓨터에서 처리하고 싶다? 
- 정확도 -> 유사도 처리만 하자. 그래서 부호 - 지수부 - 가수부를 저장하는 형태가 된 것
- 다른 언어에서는 abs(a-b) < 0.00000001 이면 같다? 뭐 이런 느낌으로 처리하는듯
