# TIL
## 수업요약
## 상속
- Inheritance 상속 : 부모 class의 속성과 메서드를 다른 class가 물려받는 것
- 필요한 이유?  
  1. 코드 재사용 : 기존 수정 안하고도 확장가능
  2. 계층 구조 : 상속을 통해 계층 표현 가능하고 더 구체적으로 만들 수 있음
  3. 유지 보수의 용이성 : 수정이 필요한 경우 해당 클래스만 수정하면 됨
- 상속의 예시
  ```python
  class Animal:
    def eat(self):
        print('먹는 중')
  
  class Dog(Animal):
    def bark(self):
        print('멍멍')
  ```
  인자로 클래스를 넣은 형태
- 상속이 없다면?  
  사람 정보를 만들 때 학생/교수따위의 정보를 별도로 표현하기 불편함  
  학생/교수 클래스를 따로 만든다면 중복된 메서드를 또 써야함
  따라서 상속의 필요성이 생김
- Method Overriding 메서드 오버라이딩 : 부모 class의 메서드를 같은 이름, 파라미터 구조로 재정의하는 것  
  자식이 부모의 메서드를 덮어써서 새로운 동작 구현 가능
  > Overloading 오버로딩  
  > 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)   
  > 파이썬은 하나의 메서드만 인식하고 인자의 형태가 다르다는 이유로 메서드를 여러 개 구분하지 않는다  

- 다중 상속 : 둘 이상의 상위 클래스로부터 상속 받는 것으로 중복되면 상속 순서대로 결정  
              상속 순서는 class(Aclass, Bclass)에서 A가 먼저
- 다이아몬드 형태의 상속이면 우선순위??  
  파이썬은 규칙을 설정. MRO(Method Resolution Order)  
  검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않음  
  복잡해지면 어떻게 순서를 알지??
- super() : 부모 클래스의 메서드를 호출하기 위해 사용하는 내장 함수  
  다중 상속 상황에서 MRO를 따르기 때문에 다음에 호출해야 할 부모를 순서대로 호출할 수 있게 함  
  ```python
  # 단일 상속
  class Person:
      def __init__(self, name, age, number, email):
          self.name = name
          self.age = age
          self.number = number
          self.email = email
  
  class Student(Person):
      def __init__(self, name, age, number, email, student_id):
          # super()를 통해 Person의 __init__ 메서드 호출
          super().__init__(name, age, number, email)
          #Person.__init__(name, age, number, email)과 같지만 부모를 지칭하는 것과 클래스를 지칭하는 것의 차이
          self.student_id = student_id
  
  
  ```  
- 아무것도 없을 때의 super()??   
  모든 오브젝트의 부모인 object가 존재하긴 하지만 '모른다'가 지금의 정답
- 



## BaekJoon.9012.괄호
- checking 변수를 만들어서 체크하는 방향으로 해결
- '('를 +1, ')'를 -1로 구현을 해서  
  -1 되면 즉시 NO+탈출하고 다 돌았을 때 0이 아니면 NO
- 처음에 구현할 때는 짝수만 생각했지만 예외를 발견해서 수정함

# BaekJoon.10828.스택
- 
